package com.testdouble.bankocr;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;

import com.google.common.collect.Sets;

/**
 * Digit contains the integer representation and the parsing logic
 * for a single digit input as a 3 column wide, 4 row tall collection of 
 * Strings.
 * 
 * @author Glenn Dayton
 * @version 1.0
 * @since 1.0
 */
public class Digit implements DigitInterface
{

    private int digit;
    private List<Integer> fingerprint;

    /**
     * Base constructor for Digit, sets the integer representation 
     * as -1, an invalid digit.
     */
    public Digit()
    {
        digit = -1;
    }

    /**
     * Constructor for setting Digit to a predefined integer passed 
     * in constructor.
     * 
     * @param _digit An integer that digit represents.
     */
    public Digit(int _digit)
    {
        fingerprint = null;
        digit = _digit;
    }

    /**
     * Constructor for invoking parsing logic for 3x4 passed List 
     * of Strings.
     * 
     * @param lines List of Strings representaing a single digit.
     */
    public Digit(List<String> lines) 
    {
        fingerprint = fingerprint(lines);
        digit = parseDigit(lines);
    }

    /**
     * This method parses a 3x4 List of Strings representing a digit.
     * 
     * @param lines 3x4 List of Strings representing unparsed digit.
     * @return Integer representation of a Stringified digit.
     * @since 1.0
     */
    public int parseDigit(List<String> lines) 
    {
        String flattened = lines.get(0) + lines.get(1) + lines.get(2);

        switch(flattened) 
        {
            case " _ | ||_|": return 0;
            case "     |  |": return 1;
            case " _  _||_ ": return 2;
            case " _  _| _|": return 3;
            case "   |_|  |": return 4;
            case " _ |_  _|": return 5;
            case " _ |_ |_|": return 6;
            case " _   |  |": return 7;
            case " _ |_||_|": return 8;
            case " _ |_| _|": return 9;
            default: return -1;
        }
    }

    /**
     * {@inheritDoc}
     * 
     * Getter method for the integer representation of digit.
     * 
     * @return Integer representation of Digit object.
     * @since 1.0
     */
    public int getDigit()
    {
        return this.digit;
    }

     /**
     * {@inheritDoc}
     * 
     * This method was overriden for use in the Entry method in search for 
     * an invalid digit. equals() determines if one digit object is equal to another.
     * 
     * @param o Object that is being compared to current object.
     * @return Returns true or false if one digit object is equal to another.
     * @since 1.0
     */
    @Override
    public boolean equals(Object o) 
    {
        if(o instanceof Digit) 
        {
            Digit toCompare = (Digit) o;
            return toCompare.getDigit() == this.digit;
        }
        return false;
    }

    /**
     * Every Digit object has it's own fingerprint which is generated by taking
     * the index of the pipe or underscore from the position that it's located.
     * 
     * @param lines A List of Strings that is 3x4
     * @return Returns a List of integer locations of the pipes or underscores.
     * @since 1.1
     */
    public List<Integer> fingerprint(List<String> lines) 
    {
        if(lines != null)
        {
            List<Integer> fingerprint = new ArrayList<Integer>();
            String flattened = lines.get(0) + lines.get(1) + lines.get(2);
            int index = 1;

            for(char s: flattened.toCharArray()) 
            {
                if(s == 124 || s == 95) // | or _
                {
                    fingerprint.add(index);
                }
                index++;
            }

            return fingerprint;
        }

        return null;
    }

    /**
     * This method returns valid integers that are off by one pipe or underscore.
     * For example a valid number 0, should return 8, since 8 can be made by adding 
     * an underscore in the middle
     * 
     * @return Returns a list of valid integers that the fingerprint could be
     * @param _fingerprint A List of integers representing the positions that pipes or underscores are present
     * @since 1.1
     */
    public List<Integer> possibleDigits()
    {
        Set<Integer> fingerprintSet = new HashSet<Integer>(this.fingerprint);

        List<Set<Integer>> fingerprints = new ArrayList<>();
        Set<Integer> zero = new HashSet<Integer>(Arrays.asList(2,4,6,7,8,9)); fingerprints.add(zero);
        Set<Integer> one = new HashSet<Integer>(Arrays.asList(6,9)); fingerprints.add(one);
        Set<Integer> two = new HashSet<Integer>(Arrays.asList(2,5,6,7,8)); fingerprints.add(two);
        Set<Integer> three = new HashSet<Integer>(Arrays.asList(2,5,6,8,9)); fingerprints.add(three);
        Set<Integer> four = new HashSet<Integer>(Arrays.asList(4,5,6,9)); fingerprints.add(four);
        Set<Integer> five = new HashSet<Integer>(Arrays.asList(2,4,5,8,9)); fingerprints.add(five);
        Set<Integer> six = new HashSet<Integer>(Arrays.asList(2,4,5,7,8,9)); fingerprints.add(six);
        Set<Integer> seven = new HashSet<Integer>(Arrays.asList(2,6,9)); fingerprints.add(seven);
        Set<Integer> eight = new HashSet<Integer>(Arrays.asList(2,4,5,6,7,8,9)); fingerprints.add(eight);
        Set<Integer> nine = new HashSet<Integer>(Arrays.asList(2,4,5,6,8,9)); fingerprints.add(nine);

        List<Integer> matches = new ArrayList<Integer>();
        int index = 0;

        for(Set<Integer> fingerprint: fingerprints) 
        {
            Set<Integer> difference = Sets.symmetricDifference(fingerprintSet, fingerprint);

            if(difference.size() == 1)
                matches.add(index);

            index++;
        }

        return matches;
    }

}